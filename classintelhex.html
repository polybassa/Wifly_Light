<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>Wifly_Light: intelhex Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Wifly_Light
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classintelhex-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">intelhex Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class to decode, encode and manipulate Intel HEX format files.  
 <a href="classintelhex.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="intelhexclass_8h_source.html">intelhexclass.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for intelhex:</div>
<div class="dyncontent">
<div class="center"><img src="classintelhex__coll__graph.png" border="0" usemap="#intelhex_coll__map" alt="Collaboration graph"/></div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae1efd0ed1f56546f8f5f5af87c6cbdd5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#ae1efd0ed1f56546f8f5f5af87c6cbdd5">intelhex</a> ()</td></tr>
<tr class="memdesc:ae1efd0ed1f56546f8f5f5af87c6cbdd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">intelhex Class Constructor.  <a href="#ae1efd0ed1f56546f8f5f5af87c6cbdd5">More...</a><br /></td></tr>
<tr class="separator:ae1efd0ed1f56546f8f5f5af87c6cbdd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a031ce4582899f5263fdcc2fa92cc3e45"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#a031ce4582899f5263fdcc2fa92cc3e45">~intelhex</a> ()</td></tr>
<tr class="memdesc:a031ce4582899f5263fdcc2fa92cc3e45"><td class="mdescLeft">&#160;</td><td class="mdescRight">intelhex Class Deconstructor.  <a href="#a031ce4582899f5263fdcc2fa92cc3e45">More...</a><br /></td></tr>
<tr class="separator:a031ce4582899f5263fdcc2fa92cc3e45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41b4c3b7851461b9240fdef90bc62768"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#a41b4c3b7851461b9240fdef90bc62768">intelhex</a> (const <a class="el" href="classintelhex.html">intelhex</a> &amp;ihSource)</td></tr>
<tr class="memdesc:a41b4c3b7851461b9240fdef90bc62768"><td class="mdescLeft">&#160;</td><td class="mdescRight">intelhex Class Copy Constructor.  <a href="#a41b4c3b7851461b9240fdef90bc62768">More...</a><br /></td></tr>
<tr class="separator:a41b4c3b7851461b9240fdef90bc62768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6408cc3141862454e846378abfad8ecc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classintelhex.html">intelhex</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#a6408cc3141862454e846378abfad8ecc">operator=</a> (const <a class="el" href="classintelhex.html">intelhex</a> &amp;ihSource)</td></tr>
<tr class="memdesc:a6408cc3141862454e846378abfad8ecc"><td class="mdescLeft">&#160;</td><td class="mdescRight">intelhex Class Assignment Operator.  <a href="#a6408cc3141862454e846378abfad8ecc">More...</a><br /></td></tr>
<tr class="separator:a6408cc3141862454e846378abfad8ecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a044d6ab5b10a38ffa40a0b1f55b7e808"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classintelhex.html">intelhex</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#a044d6ab5b10a38ffa40a0b1f55b7e808">operator++</a> ()</td></tr>
<tr class="memdesc:a044d6ab5b10a38ffa40a0b1f55b7e808"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloaded prefix increment operator.  <a href="#a044d6ab5b10a38ffa40a0b1f55b7e808">More...</a><br /></td></tr>
<tr class="separator:a044d6ab5b10a38ffa40a0b1f55b7e808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab54337b9681fc0b50e3fdb18ed1714fa"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classintelhex.html">intelhex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#ab54337b9681fc0b50e3fdb18ed1714fa">operator++</a> (int)</td></tr>
<tr class="memdesc:ab54337b9681fc0b50e3fdb18ed1714fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloaded postfix increment operator.  <a href="#ab54337b9681fc0b50e3fdb18ed1714fa">More...</a><br /></td></tr>
<tr class="separator:ab54337b9681fc0b50e3fdb18ed1714fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab85cbeafe9cc6adcec79f1bc709addca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classintelhex.html">intelhex</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#ab85cbeafe9cc6adcec79f1bc709addca">operator--</a> ()</td></tr>
<tr class="memdesc:ab85cbeafe9cc6adcec79f1bc709addca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloaded prefix decrement operator.  <a href="#ab85cbeafe9cc6adcec79f1bc709addca">More...</a><br /></td></tr>
<tr class="separator:ab85cbeafe9cc6adcec79f1bc709addca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90562846d95b5573923f129b82aeceec"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classintelhex.html">intelhex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#a90562846d95b5573923f129b82aeceec">operator--</a> (int)</td></tr>
<tr class="memdesc:a90562846d95b5573923f129b82aeceec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloaded postfix decrement operator.  <a href="#a90562846d95b5573923f129b82aeceec">More...</a><br /></td></tr>
<tr class="separator:a90562846d95b5573923f129b82aeceec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2b1119e14a960ea2b356967244aafb3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#ab2b1119e14a960ea2b356967244aafb3">begin</a> ()</td></tr>
<tr class="memdesc:ab2b1119e14a960ea2b356967244aafb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the address pointer to the first available address.  <a href="#ab2b1119e14a960ea2b356967244aafb3">More...</a><br /></td></tr>
<tr class="separator:ab2b1119e14a960ea2b356967244aafb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7759926596cfcffec94e391fff4298e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#a7759926596cfcffec94e391fff4298e9">end</a> ()</td></tr>
<tr class="memdesc:a7759926596cfcffec94e391fff4298e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the address pointer to the last available address.  <a href="#a7759926596cfcffec94e391fff4298e9">More...</a><br /></td></tr>
<tr class="separator:a7759926596cfcffec94e391fff4298e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa757932ec420f977d33bb9a2d5a0a69"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#afa757932ec420f977d33bb9a2d5a0a69">size</a> ()</td></tr>
<tr class="memdesc:afa757932ec420f977d33bb9a2d5a0a69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if we have reached end of available data.  <a href="#afa757932ec420f977d33bb9a2d5a0a69">More...</a><br /></td></tr>
<tr class="separator:afa757932ec420f977d33bb9a2d5a0a69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff915b320f5a4c2d84340fa57c99499c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#aff915b320f5a4c2d84340fa57c99499c">endOfData</a> ()</td></tr>
<tr class="memdesc:aff915b320f5a4c2d84340fa57c99499c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if we have reached end of available data.  <a href="#aff915b320f5a4c2d84340fa57c99499c">More...</a><br /></td></tr>
<tr class="separator:aff915b320f5a4c2d84340fa57c99499c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bd5b567207303d4d9f4322e6262d6d6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#a2bd5b567207303d4d9f4322e6262d6d6">empty</a> ()</td></tr>
<tr class="separator:a2bd5b567207303d4d9f4322e6262d6d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83b54457c121b0f35b21b78fa2ecd712"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#a83b54457c121b0f35b21b78fa2ecd712">jumpTo</a> (unsigned long address)</td></tr>
<tr class="memdesc:a83b54457c121b0f35b21b78fa2ecd712"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the address pointer to the desired address.  <a href="#a83b54457c121b0f35b21b78fa2ecd712">More...</a><br /></td></tr>
<tr class="separator:a83b54457c121b0f35b21b78fa2ecd712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9c6e296e5053fe8378e79445cf480cb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#af9c6e296e5053fe8378e79445cf480cb">incrementAddress</a> ()</td></tr>
<tr class="memdesc:af9c6e296e5053fe8378e79445cf480cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments to next piece of data.  <a href="#af9c6e296e5053fe8378e79445cf480cb">More...</a><br /></td></tr>
<tr class="separator:af9c6e296e5053fe8378e79445cf480cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51f6d93f1ac2bdf5ddad8be4e1827ce9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#a51f6d93f1ac2bdf5ddad8be4e1827ce9">decrementAddress</a> ()</td></tr>
<tr class="memdesc:a51f6d93f1ac2bdf5ddad8be4e1827ce9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrements to next piece of data.  <a href="#a51f6d93f1ac2bdf5ddad8be4e1827ce9">More...</a><br /></td></tr>
<tr class="separator:a51f6d93f1ac2bdf5ddad8be4e1827ce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a631d8930daeaf04bf0d9ad9c25679a0b"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#a631d8930daeaf04bf0d9ad9c25679a0b">currentAddress</a> ()</td></tr>
<tr class="memdesc:a631d8930daeaf04bf0d9ad9c25679a0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current address being pointed to.  <a href="#a631d8930daeaf04bf0d9ad9c25679a0b">More...</a><br /></td></tr>
<tr class="separator:a631d8930daeaf04bf0d9ad9c25679a0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8833665b99f0b6ac64fcef7d2116c42"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#aa8833665b99f0b6ac64fcef7d2116c42">startAddress</a> (unsigned long *address)</td></tr>
<tr class="memdesc:aa8833665b99f0b6ac64fcef7d2116c42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the lowest address currently available.  <a href="#aa8833665b99f0b6ac64fcef7d2116c42">More...</a><br /></td></tr>
<tr class="separator:aa8833665b99f0b6ac64fcef7d2116c42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b159bea81eb832e37f6cf88a57ca659"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#a9b159bea81eb832e37f6cf88a57ca659">endAddress</a> (unsigned long *address)</td></tr>
<tr class="memdesc:a9b159bea81eb832e37f6cf88a57ca659"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the highest address currently available.  <a href="#a9b159bea81eb832e37f6cf88a57ca659">More...</a><br /></td></tr>
<tr class="separator:a9b159bea81eb832e37f6cf88a57ca659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01f7799f7a86e45c28b713e9472a8a5a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#a01f7799f7a86e45c28b713e9472a8a5a">getData</a> (unsigned char *data)</td></tr>
<tr class="memdesc:a01f7799f7a86e45c28b713e9472a8a5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the data to which the iterator is currently pointing.  <a href="#a01f7799f7a86e45c28b713e9472a8a5a">More...</a><br /></td></tr>
<tr class="separator:a01f7799f7a86e45c28b713e9472a8a5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6596b518a9a832ed8e6ba21a0e07861c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#a6596b518a9a832ed8e6ba21a0e07861c">getData</a> (unsigned char *data, unsigned long address)</td></tr>
<tr class="memdesc:a6596b518a9a832ed8e6ba21a0e07861c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the data for desired address.  <a href="#a6596b518a9a832ed8e6ba21a0e07861c">More...</a><br /></td></tr>
<tr class="separator:a6596b518a9a832ed8e6ba21a0e07861c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71096983db3c24a5ac9b95663937a4ce"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#a71096983db3c24a5ac9b95663937a4ce">insertData</a> (unsigned char data)</td></tr>
<tr class="memdesc:a71096983db3c24a5ac9b95663937a4ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts desired byte at the current address pointer.  <a href="#a71096983db3c24a5ac9b95663937a4ce">More...</a><br /></td></tr>
<tr class="separator:a71096983db3c24a5ac9b95663937a4ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00ff4c491fabc5ef207071358e1b9298"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#a00ff4c491fabc5ef207071358e1b9298">insertData</a> (unsigned char data, unsigned long address)</td></tr>
<tr class="separator:a00ff4c491fabc5ef207071358e1b9298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4fc2715f4c63d3f31e8d2b0533583e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#ab4fc2715f4c63d3f31e8d2b0533583e5">overwriteData</a> (unsigned char data)</td></tr>
<tr class="separator:ab4fc2715f4c63d3f31e8d2b0533583e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83edcd2329cb52a4bab6bb46463184d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#a83edcd2329cb52a4bab6bb46463184d7">overwriteData</a> (unsigned char data, unsigned long address)</td></tr>
<tr class="separator:a83edcd2329cb52a4bab6bb46463184d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5de5cf10103fc307127f9017f3e5cd76"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#a5de5cf10103fc307127f9017f3e5cd76">blankFill</a> (unsigned char data)</td></tr>
<tr class="separator:a5de5cf10103fc307127f9017f3e5cd76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84bbd449bb55e218b62ea73e2b399196"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#a84bbd449bb55e218b62ea73e2b399196">blankFill</a> (unsigned char *const data, unsigned long sizeOfData)</td></tr>
<tr class="separator:a84bbd449bb55e218b62ea73e2b399196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf6f77af7a82623ef16471f105ac3fe7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#aaf6f77af7a82623ef16471f105ac3fe7">blankFill</a> (unsigned char *const data, unsigned long sizeOfData, unsigned long <a class="el" href="classintelhex.html#a9b159bea81eb832e37f6cf88a57ca659">endAddress</a>)</td></tr>
<tr class="separator:aaf6f77af7a82623ef16471f105ac3fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c26ba3dc9dd4f3021bb6c7f6983388f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#a9c26ba3dc9dd4f3021bb6c7f6983388f">blankFillRandom</a> ()</td></tr>
<tr class="separator:a9c26ba3dc9dd4f3021bb6c7f6983388f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1dbcbf3df1aaafd518882c882f43f76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#aa1dbcbf3df1aaafd518882c882f43f76">blankFillRandom</a> (unsigned long <a class="el" href="classintelhex.html#a9b159bea81eb832e37f6cf88a57ca659">endAddress</a>)</td></tr>
<tr class="separator:aa1dbcbf3df1aaafd518882c882f43f76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e5c67fccc34c78e6dbd28f4b795fb0f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#a2e5c67fccc34c78e6dbd28f4b795fb0f">blankFillAddressLowByte</a> ()</td></tr>
<tr class="separator:a2e5c67fccc34c78e6dbd28f4b795fb0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7b16f457563da93569b9812fafb9e7d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#ab7b16f457563da93569b9812fafb9e7d">blankFillAddressLowByte</a> (unsigned long <a class="el" href="classintelhex.html#a9b159bea81eb832e37f6cf88a57ca659">endAddress</a>)</td></tr>
<tr class="separator:ab7b16f457563da93569b9812fafb9e7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05a19e1e9f1eb493a8d0bc29db88683f"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#a05a19e1e9f1eb493a8d0bc29db88683f">getNoWarnings</a> ()</td></tr>
<tr class="memdesc:a05a19e1e9f1eb493a8d0bc29db88683f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns number of unread warning messages.  <a href="#a05a19e1e9f1eb493a8d0bc29db88683f">More...</a><br /></td></tr>
<tr class="separator:a05a19e1e9f1eb493a8d0bc29db88683f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77cddd46c3f97692b4d89f138bdabb72"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#a77cddd46c3f97692b4d89f138bdabb72">getNoErrors</a> ()</td></tr>
<tr class="memdesc:a77cddd46c3f97692b4d89f138bdabb72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns number of unread error messages.  <a href="#a77cddd46c3f97692b4d89f138bdabb72">More...</a><br /></td></tr>
<tr class="separator:a77cddd46c3f97692b4d89f138bdabb72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab881b8cb0fe665395a29e4375db8f7c4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#ab881b8cb0fe665395a29e4375db8f7c4">popNextWarning</a> (string &amp;warning)</td></tr>
<tr class="memdesc:ab881b8cb0fe665395a29e4375db8f7c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop next warning message from the list of warnings.  <a href="#ab881b8cb0fe665395a29e4375db8f7c4">More...</a><br /></td></tr>
<tr class="separator:ab881b8cb0fe665395a29e4375db8f7c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6609fd1c57a650c45a1961f6318d643e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#a6609fd1c57a650c45a1961f6318d643e">popNextError</a> (string &amp;error)</td></tr>
<tr class="memdesc:a6609fd1c57a650c45a1961f6318d643e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop next error message from the list of errors.  <a href="#a6609fd1c57a650c45a1961f6318d643e">More...</a><br /></td></tr>
<tr class="separator:a6609fd1c57a650c45a1961f6318d643e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94d6d17ba22263a4775d80b2a0e6e95f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#a94d6d17ba22263a4775d80b2a0e6e95f">getStartSegmentAddress</a> (unsigned short *<a class="el" href="classintelhex.html#acf63100ba6ba58da893f29596560efbd">ipRegister</a>, unsigned short *<a class="el" href="classintelhex.html#aabbf5689bc667734dca7f23a11d3df68">csRegister</a>)</td></tr>
<tr class="memdesc:a94d6d17ba22263a4775d80b2a0e6e95f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns segment start address for the IP and ES registers.  <a href="#a94d6d17ba22263a4775d80b2a0e6e95f">More...</a><br /></td></tr>
<tr class="separator:a94d6d17ba22263a4775d80b2a0e6e95f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bc61f72756d37509e768906733ba10b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#a7bc61f72756d37509e768906733ba10b">getStartLinearAddress</a> (unsigned long *<a class="el" href="classintelhex.html#abedd6ca388d3cad1d2525abc5939d27e">eipRegister</a>)</td></tr>
<tr class="memdesc:a7bc61f72756d37509e768906733ba10b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns segment linear address for the EIP register.  <a href="#a7bc61f72756d37509e768906733ba10b">More...</a><br /></td></tr>
<tr class="separator:a7bc61f72756d37509e768906733ba10b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9688f0002be870b05d64b5f9fcdeb86b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#a9688f0002be870b05d64b5f9fcdeb86b">setStartSegmentAddress</a> (unsigned short <a class="el" href="classintelhex.html#acf63100ba6ba58da893f29596560efbd">ipRegister</a>, unsigned short <a class="el" href="classintelhex.html#aabbf5689bc667734dca7f23a11d3df68">csRegister</a>)</td></tr>
<tr class="memdesc:a9688f0002be870b05d64b5f9fcdeb86b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the segment start address for the IP and CS registers.  <a href="#a9688f0002be870b05d64b5f9fcdeb86b">More...</a><br /></td></tr>
<tr class="separator:a9688f0002be870b05d64b5f9fcdeb86b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7629ca097b2de02dea37fcaa2dc2709c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#a7629ca097b2de02dea37fcaa2dc2709c">setStartLinearAddress</a> (unsigned long <a class="el" href="classintelhex.html#abedd6ca388d3cad1d2525abc5939d27e">eipRegister</a>)</td></tr>
<tr class="memdesc:a7629ca097b2de02dea37fcaa2dc2709c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the segment start address for the EIP register.  <a href="#a7629ca097b2de02dea37fcaa2dc2709c">More...</a><br /></td></tr>
<tr class="separator:a7629ca097b2de02dea37fcaa2dc2709c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a489fc3b9c34542def2a5167192b291da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#a489fc3b9c34542def2a5167192b291da">segmentAddressingOn</a> ()</td></tr>
<tr class="memdesc:a489fc3b9c34542def2a5167192b291da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turns on segment addressing mode during encoding.  <a href="#a489fc3b9c34542def2a5167192b291da">More...</a><br /></td></tr>
<tr class="separator:a489fc3b9c34542def2a5167192b291da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5055edd337d19037ab254a27016267f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#a5055edd337d19037ab254a27016267f8">linearAddressingOn</a> ()</td></tr>
<tr class="memdesc:a5055edd337d19037ab254a27016267f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turns on linear addressing mode during encoding.  <a href="#a5055edd337d19037ab254a27016267f8">More...</a><br /></td></tr>
<tr class="separator:a5055edd337d19037ab254a27016267f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6a0119a04a2090af3ffe8c33a37cbc9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#ac6a0119a04a2090af3ffe8c33a37cbc9">verboseOn</a> ()</td></tr>
<tr class="memdesc:ac6a0119a04a2090af3ffe8c33a37cbc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turns on textual output to cout during decoding.  <a href="#ac6a0119a04a2090af3ffe8c33a37cbc9">More...</a><br /></td></tr>
<tr class="separator:ac6a0119a04a2090af3ffe8c33a37cbc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3958f077a662291bbde3472ea2bcfb4d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#a3958f077a662291bbde3472ea2bcfb4d">verboseOff</a> ()</td></tr>
<tr class="memdesc:a3958f077a662291bbde3472ea2bcfb4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turns off textual output to cout during decoding.  <a href="#a3958f077a662291bbde3472ea2bcfb4d">More...</a><br /></td></tr>
<tr class="separator:a3958f077a662291bbde3472ea2bcfb4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a5adb32f7af4a3c75fd0745ef2827da9a"><td class="memItemLeft" align="right" valign="top">unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#a5adb32f7af4a3c75fd0745ef2827da9a">stringToHex</a> (string value)</td></tr>
<tr class="separator:a5adb32f7af4a3c75fd0745ef2827da9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af45f701889bcd7e5d25066a69e0f91bf"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#af45f701889bcd7e5d25066a69e0f91bf">ulToHexString</a> (unsigned long value)</td></tr>
<tr class="separator:af45f701889bcd7e5d25066a69e0f91bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3185843e9397b26ccd330ead0a9a7bed"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#a3185843e9397b26ccd330ead0a9a7bed">ucToHexString</a> (unsigned char value)</td></tr>
<tr class="memdesc:a3185843e9397b26ccd330ead0a9a7bed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an unsigned char to a string in HEX format.  <a href="#a3185843e9397b26ccd330ead0a9a7bed">More...</a><br /></td></tr>
<tr class="separator:a3185843e9397b26ccd330ead0a9a7bed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15904358dffd75ddded56657675f3c04"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#a15904358dffd75ddded56657675f3c04">ulToString</a> (unsigned long value)</td></tr>
<tr class="memdesc:a15904358dffd75ddded56657675f3c04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an unsigned long to a string in DEC format.  <a href="#a15904358dffd75ddded56657675f3c04">More...</a><br /></td></tr>
<tr class="separator:a15904358dffd75ddded56657675f3c04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58cd289e3cac113630c1925e391e29d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#a58cd289e3cac113630c1925e391e29d9">decodeDataRecord</a> (unsigned char recordLength, unsigned long loadOffset, string::const_iterator data)</td></tr>
<tr class="memdesc:a58cd289e3cac113630c1925e391e29d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes the data content of a data record.  <a href="#a58cd289e3cac113630c1925e391e29d9">More...</a><br /></td></tr>
<tr class="separator:a58cd289e3cac113630c1925e391e29d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c0be2c34550af96766e32dcbc7cbf37"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#a4c0be2c34550af96766e32dcbc7cbf37">addWarning</a> (string warningMessage)</td></tr>
<tr class="memdesc:a4c0be2c34550af96766e32dcbc7cbf37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a warning message to the warning message list.  <a href="#a4c0be2c34550af96766e32dcbc7cbf37">More...</a><br /></td></tr>
<tr class="separator:a4c0be2c34550af96766e32dcbc7cbf37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ad7e4af211dd3aabd79c18f96e9d7f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#a1ad7e4af211dd3aabd79c18f96e9d7f7">addError</a> (string errorMessage)</td></tr>
<tr class="memdesc:a1ad7e4af211dd3aabd79c18f96e9d7f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an error message to the error message list.  <a href="#a1ad7e4af211dd3aabd79c18f96e9d7f7">More...</a><br /></td></tr>
<tr class="separator:a1ad7e4af211dd3aabd79c18f96e9d7f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a5add4e9b26e1c467296bec8a94d4ee65"><td class="memItemLeft" align="right" valign="top">map&lt; unsigned long, unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#a5add4e9b26e1c467296bec8a94d4ee65">ihContent</a></td></tr>
<tr class="memdesc:a5add4e9b26e1c467296bec8a94d4ee65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container for decoded Intel HEX content.  <a href="#a5add4e9b26e1c467296bec8a94d4ee65">More...</a><br /></td></tr>
<tr class="separator:a5add4e9b26e1c467296bec8a94d4ee65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accc24f65b09b8cbe43ec9dba0f315f83"><td class="memItemLeft" align="right" valign="top">map&lt; unsigned long, unsigned <br class="typebreak" />
char &gt;::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#accc24f65b09b8cbe43ec9dba0f315f83">ihIterator</a></td></tr>
<tr class="memdesc:accc24f65b09b8cbe43ec9dba0f315f83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator for the container holding the decoded Intel HEX content.  <a href="#accc24f65b09b8cbe43ec9dba0f315f83">More...</a><br /></td></tr>
<tr class="separator:accc24f65b09b8cbe43ec9dba0f315f83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4adf41a09983f0f78a11c8fc392c33f8"><td class="memItemLeft" align="right" valign="top">pair&lt; map&lt; unsigned long, <br class="typebreak" />
unsigned char &gt;::iterator, <br class="typebreak" />
bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#a4adf41a09983f0f78a11c8fc392c33f8">ihReturn</a></td></tr>
<tr class="memdesc:a4adf41a09983f0f78a11c8fc392c33f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pair for the container holding the decoded Intel HEX content.  <a href="#a4adf41a09983f0f78a11c8fc392c33f8">More...</a><br /></td></tr>
<tr class="separator:a4adf41a09983f0f78a11c8fc392c33f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacb1421e6ecfde72ec6b164d361442d6"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#aacb1421e6ecfde72ec6b164d361442d6">segmentBaseAddress</a></td></tr>
<tr class="memdesc:aacb1421e6ecfde72ec6b164d361442d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores segment base address of Intel HEX file.  <a href="#aacb1421e6ecfde72ec6b164d361442d6">More...</a><br /></td></tr>
<tr class="separator:aacb1421e6ecfde72ec6b164d361442d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab150a4a21506ce25cf3cb1123478ca0c"><td class="memItemLeft" >struct {</td></tr>
<tr class="memitem:a6c6b2cb362c27f2f7278c62682b19f88"><td class="memItemLeft" >&#160;&#160;&#160;unsigned short&#160;&#160;&#160;<a class="el" href="classintelhex.html#aabbf5689bc667734dca7f23a11d3df68">csRegister</a></td></tr>
<tr class="separator:a6c6b2cb362c27f2f7278c62682b19f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75318d2c32a371cff35cc28596722825"><td class="memItemLeft" >&#160;&#160;&#160;unsigned short&#160;&#160;&#160;<a class="el" href="classintelhex.html#acf63100ba6ba58da893f29596560efbd">ipRegister</a></td></tr>
<tr class="separator:a75318d2c32a371cff35cc28596722825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a884033e8d4a9c4f88bc552cfb323f6bd"><td class="memItemLeft" >&#160;&#160;&#160;bool&#160;&#160;&#160;<a class="el" href="classintelhex.html#ab58b4357deef8e4f0af9817393fc0b6e">exists</a></td></tr>
<tr class="separator:a884033e8d4a9c4f88bc552cfb323f6bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab150a4a21506ce25cf3cb1123478ca0c"><td class="memItemLeft" valign="top">}&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#ab150a4a21506ce25cf3cb1123478ca0c">startSegmentAddress</a></td></tr>
<tr class="memdesc:ab150a4a21506ce25cf3cb1123478ca0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the content of the CS/IP Registers, if used.  <a href="#ab150a4a21506ce25cf3cb1123478ca0c">More...</a><br /></td></tr>
<tr class="separator:ab150a4a21506ce25cf3cb1123478ca0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08bee84b2ef4f989a5f15f9eeaf317ac"><td class="memItemLeft" >struct {</td></tr>
<tr class="memitem:a023fa12e537bb52053150a5a3e8c9e11"><td class="memItemLeft" >&#160;&#160;&#160;unsigned long&#160;&#160;&#160;<a class="el" href="classintelhex.html#abedd6ca388d3cad1d2525abc5939d27e">eipRegister</a></td></tr>
<tr class="separator:a023fa12e537bb52053150a5a3e8c9e11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a359c9c580012f84aa63eb08167bc089d"><td class="memItemLeft" >&#160;&#160;&#160;bool&#160;&#160;&#160;<a class="el" href="classintelhex.html#ab58b4357deef8e4f0af9817393fc0b6e">exists</a></td></tr>
<tr class="separator:a359c9c580012f84aa63eb08167bc089d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08bee84b2ef4f989a5f15f9eeaf317ac"><td class="memItemLeft" valign="top">}&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#a08bee84b2ef4f989a5f15f9eeaf317ac">startLinearAddress</a></td></tr>
<tr class="memdesc:a08bee84b2ef4f989a5f15f9eeaf317ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the content of the EIP Register, if used.  <a href="#a08bee84b2ef4f989a5f15f9eeaf317ac">More...</a><br /></td></tr>
<tr class="separator:a08bee84b2ef4f989a5f15f9eeaf317ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1125751a09a972c8ce56d51b6b89d4e7"><td class="memItemLeft" >struct {</td></tr>
<tr class="memitem:a7dd5d2bb0343497cb82691c232d19877"><td class="memItemLeft" >&#160;&#160;&#160;list&lt; string &gt;&#160;&#160;&#160;<a class="el" href="classintelhex.html#a0ae0e9a75bdfaa50d6d0266bb3d56ed1">ihWarnings</a></td></tr>
<tr class="separator:a7dd5d2bb0343497cb82691c232d19877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2bce38fc79942d5977603ee0c453759"><td class="memItemLeft" >&#160;&#160;&#160;unsigned long&#160;&#160;&#160;<a class="el" href="classintelhex.html#a5ea3789cc9ea71c9b35322aabca05158">noOfWarnings</a></td></tr>
<tr class="separator:aa2bce38fc79942d5977603ee0c453759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1125751a09a972c8ce56d51b6b89d4e7"><td class="memItemLeft" valign="top">}&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#a1125751a09a972c8ce56d51b6b89d4e7">msgWarning</a></td></tr>
<tr class="memdesc:a1125751a09a972c8ce56d51b6b89d4e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to hold warning messages.  <a href="#a1125751a09a972c8ce56d51b6b89d4e7">More...</a><br /></td></tr>
<tr class="separator:a1125751a09a972c8ce56d51b6b89d4e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3bf00fb9b05d5ed791f38995d510176"><td class="memItemLeft" >struct {</td></tr>
<tr class="memitem:a65c3417b74c4a7baf025ae9eee3b418e"><td class="memItemLeft" >&#160;&#160;&#160;list&lt; string &gt;&#160;&#160;&#160;<a class="el" href="classintelhex.html#a76fb4550b43dfbb08018cabf34298400">ihErrors</a></td></tr>
<tr class="separator:a65c3417b74c4a7baf025ae9eee3b418e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2449c5cbd6da5f8a3e67d092494632a"><td class="memItemLeft" >&#160;&#160;&#160;unsigned long&#160;&#160;&#160;<a class="el" href="classintelhex.html#a451b78972165b898e91a129670fce919">noOfErrors</a></td></tr>
<tr class="separator:ad2449c5cbd6da5f8a3e67d092494632a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3bf00fb9b05d5ed791f38995d510176"><td class="memItemLeft" valign="top">}&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#ab3bf00fb9b05d5ed791f38995d510176">msgError</a></td></tr>
<tr class="memdesc:ab3bf00fb9b05d5ed791f38995d510176"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to hold error messages.  <a href="#ab3bf00fb9b05d5ed791f38995d510176">More...</a><br /></td></tr>
<tr class="separator:ab3bf00fb9b05d5ed791f38995d510176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a757b3e3037a34caf004981aed2a297b6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#a757b3e3037a34caf004981aed2a297b6">foundEof</a></td></tr>
<tr class="memdesc:a757b3e3037a34caf004981aed2a297b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Note that EOF record is found.  <a href="#a757b3e3037a34caf004981aed2a297b6">More...</a><br /></td></tr>
<tr class="separator:a757b3e3037a34caf004981aed2a297b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65f440d3762d1b9437b7473c4df3bb8f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#a65f440d3762d1b9437b7473c4df3bb8f">verbose</a></td></tr>
<tr class="memdesc:a65f440d3762d1b9437b7473c4df3bb8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select verbose mode.  <a href="#a65f440d3762d1b9437b7473c4df3bb8f">More...</a><br /></td></tr>
<tr class="separator:a65f440d3762d1b9437b7473c4df3bb8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5831ba42a6d900b6b01bade869ac06e7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#a5831ba42a6d900b6b01bade869ac06e7">segmentAddressMode</a></td></tr>
<tr class="memdesc:a5831ba42a6d900b6b01bade869ac06e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select segment address mode.  <a href="#a5831ba42a6d900b6b01bade869ac06e7">More...</a><br /></td></tr>
<tr class="separator:a5831ba42a6d900b6b01bade869ac06e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a320e23dab311a6c652aa7ddb9e2f9cc2"><td class="memItemLeft" align="right" valign="top">ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#a320e23dab311a6c652aa7ddb9e2f9cc2">operator&lt;&lt;</a> (ostream &amp;dataOut, <a class="el" href="classintelhex.html">intelhex</a> &amp;ihLocal)</td></tr>
<tr class="memdesc:a320e23dab311a6c652aa7ddb9e2f9cc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output stream overload operator.  <a href="#a320e23dab311a6c652aa7ddb9e2f9cc2">More...</a><br /></td></tr>
<tr class="separator:a320e23dab311a6c652aa7ddb9e2f9cc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73fb9c5b9d6d069b5eb83340942fd54b"><td class="memItemLeft" align="right" valign="top">istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#a73fb9c5b9d6d069b5eb83340942fd54b">operator&gt;&gt;</a> (istream &amp;dataIn, <a class="el" href="classintelhex.html">intelhex</a> &amp;ihLocal)</td></tr>
<tr class="memdesc:a73fb9c5b9d6d069b5eb83340942fd54b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input stream overload operator.  <a href="#a73fb9c5b9d6d069b5eb83340942fd54b">More...</a><br /></td></tr>
<tr class="separator:a73fb9c5b9d6d069b5eb83340942fd54b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class to decode, encode and manipulate Intel HEX format files. </p>
<p>The Intel HEX class allows the user to stream in the content of an Intel HEX file so that its content can by analysed more easily than trying to decode the Intel HEX file in a text editor. In conjunction with a suitable application it is possible to create content, analyse content and even compare the content of files with one another. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ae1efd0ed1f56546f8f5f5af87c6cbdd5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">intelhex::intelhex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>intelhex Class Constructor. </p>
<p>Important initialisation steps performed here:</p><ul>
<li>clear segment base address to zero</li>
<li>clear all x86 start address registers to zero</li>
<li>note that there are, as yet, no errors or warnings</li>
<li>note that the EOF record has not yet been found</li>
<li>set verbode mode to 'false' (default)</li>
<li>initialise class ihIterator </li>
</ul>

</div>
</div>
<a class="anchor" id="a031ce4582899f5263fdcc2fa92cc3e45"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">intelhex::~intelhex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>intelhex Class Deconstructor. </p>
<p>Currently the deconstructor is intentially empty. </p>

</div>
</div>
<a class="anchor" id="a41b4c3b7851461b9240fdef90bc62768"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">intelhex::intelhex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classintelhex.html">intelhex</a> &amp;&#160;</td>
          <td class="paramname"><em>ihSource</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>intelhex Class Copy Constructor. </p>
<p>Copy constructor copies all essential elements for the class. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a1ad7e4af211dd3aabd79c18f96e9d7f7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void intelhex::addError </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>errorMessage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add an error message to the error message list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">errorMessage</td><td>- the text to be added for this error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4c0be2c34550af96766e32dcbc7cbf37"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void intelhex::addWarning </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>warningMessage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a warning message to the warning message list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">warningMessage</td><td>- the text to be added for this warning </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab2b1119e14a960ea2b356967244aafb3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void intelhex::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the address pointer to the first available address. </p>
<p>The address pointer will be moved to the first available address in memory of the decoded file or of the data the user has inserted into memory for the purpose of encoding into the Intel HEX format.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classintelhex.html#a7759926596cfcffec94e391fff4298e9" title="Moves the address pointer to the last available address. ">end()</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function has no effect if no file has been as yet decoded and no data has been inserted into memory. </dd></dl>

</div>
</div>
<a class="anchor" id="a5de5cf10103fc307127f9017f3e5cd76"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool intelhex::blankFill </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a84bbd449bb55e218b62ea73e2b399196"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool intelhex::blankFill </td>
          <td>(</td>
          <td class="paramtype">unsigned char *const&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>sizeOfData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aaf6f77af7a82623ef16471f105ac3fe7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void intelhex::blankFill </td>
          <td>(</td>
          <td class="paramtype">unsigned char *const&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>sizeOfData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>endAddress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a2e5c67fccc34c78e6dbd28f4b795fb0f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool intelhex::blankFillAddressLowByte </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab7b16f457563da93569b9812fafb9e7d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void intelhex::blankFillAddressLowByte </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>endAddress</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9c26ba3dc9dd4f3021bb6c7f6983388f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool intelhex::blankFillRandom </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa1dbcbf3df1aaafd518882c882f43f76"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void intelhex::blankFillRandom </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>endAddress</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a631d8930daeaf04bf0d9ad9c25679a0b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long intelhex::currentAddress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current address being pointed to. </p>
<p>Current address will be returned.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classintelhex.html#a83b54457c121b0f35b21b78fa2ecd712" title="Moves the address pointer to the desired address. ">jumpTo()</a></dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Current</td><td>address being pointed to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a58cd289e3cac113630c1925e391e29d9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void intelhex::decodeDataRecord </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>recordLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>loadOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string::const_iterator&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decodes the data content of a data record. </p>
<p>Takes the data element of a data record in string format, converts each 2 char element into a single byte and then inserts that byte of data into the ihContent STL map.</p>
<dl class="section see"><dt>See also</dt><dd>encodeDataRecord()</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recordLength</td><td>- Number of bytes in this record as extracted from this line in the Intel HEX file </td></tr>
    <tr><td class="paramname">loadOffset</td><td>- The offset from the segment base address for the first byte in this record </td></tr>
    <tr><td class="paramname">data</td><td>- The data content of the record in a string </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a51f6d93f1ac2bdf5ddad8be4e1827ce9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool intelhex::decrementAddress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decrements to next piece of data. </p>
<p>Address pointer will take on the address of the previous location for which there is data.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classintelhex.html#af9c6e296e5053fe8378e79445cf480cb" title="Increments to next piece of data. ">incrementAddress()</a></dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>- pointer was decremented; a new data value was found </td></tr>
    <tr><td class="paramname">false</td><td>- start of available data reached; pointer is unchanged </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2bd5b567207303d4d9f4322e6262d6d6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool intelhex::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7759926596cfcffec94e391fff4298e9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void intelhex::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the address pointer to the last available address. </p>
<p>The address pointer will be moved to the last available address in memory of the decoded file or of the data the user has inserted into memory for the purpose of encoding into the Intel HEX format.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classintelhex.html#ab2b1119e14a960ea2b356967244aafb3" title="Moves the address pointer to the first available address. ">begin()</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function has no effect if no file has been as yet decoded and no data has been inserted into memory. </dd></dl>

</div>
</div>
<a class="anchor" id="a9b159bea81eb832e37f6cf88a57ca659"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool intelhex::endAddress </td>
          <td>(</td>
          <td class="paramtype">unsigned long *&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the highest address currently available. </p>
<p>Returns the last address that appears in the memory if there is data present. If not, no value will be returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>- variable to hold address requested</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>- address existed and returned value is valid </td></tr>
    <tr><td class="paramname">false</td><td>- address did not exist and returned valid is not valid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classintelhex.html#aa8833665b99f0b6ac64fcef7d2116c42" title="Returns the lowest address currently available. ">startAddress()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aff915b320f5a4c2d84340fa57c99499c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool intelhex::endOfData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if we have reached end of available data. </p>
<p>The internal pointer is checked to see if we have reached the end of the data held in memory</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classintelhex.html#a044d6ab5b10a38ffa40a0b1f55b7e808" title="Overloaded prefix increment operator. ">operator++()</a>, <a class="el" href="classintelhex.html#ab54337b9681fc0b50e3fdb18ed1714fa" title="Overloaded postfix increment operator. ">operator++(int)</a>, <a class="el" href="classintelhex.html#ab85cbeafe9cc6adcec79f1bc709addca" title="Overloaded prefix decrement operator. ">operator--()</a>, <a class="el" href="classintelhex.html#a90562846d95b5573923f129b82aeceec" title="Overloaded postfix decrement operator. ">operator--(int)</a>, <a class="el" href="classintelhex.html#a2bd5b567207303d4d9f4322e6262d6d6">empty()</a></dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>- reached the end of the Intel HEX data in memory or no data in memory yet. </td></tr>
    <tr><td class="paramname">false</td><td>- end of Intel HEX data in memory not yet reached.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function has no effect if no file has been as yet decoded and no data has been inserted into memory. </dd></dl>

</div>
</div>
<a class="anchor" id="a01f7799f7a86e45c28b713e9472a8a5a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool intelhex::getData </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the data to which the iterator is currently pointing. </p>
<p>Returns the data to which the internal iterator (pointer) is currently pointing. If no data is in memory, this function returns false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>- variable to hold data requested</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>- data was available and returned value is valid </td></tr>
    <tr><td class="paramname">false</td><td>- data was not available and returned valid is not valid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>putData() </dd></dl>

</div>
</div>
<a class="anchor" id="a6596b518a9a832ed8e6ba21a0e07861c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool intelhex::getData </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the data for desired address. </p>
<p>Returns the data for the desired address. If the address has no data assigned to it, the function returns false, the pointer to data is not written and the class's address pointer remains unchanged. If the address has data assigned to it, the pointer to data will be written with the data found and the class's address pointer will be moved to this new location.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>- variable to hold data requested </td></tr>
    <tr><td class="paramname">address</td><td>- address to be queried for valid data</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>- data was available and returned value is valid </td></tr>
    <tr><td class="paramname">false</td><td>- data was not available and returned valid is not valid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>putData() </dd></dl>

</div>
</div>
<a class="anchor" id="a77cddd46c3f97692b4d89f138bdabb72"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long intelhex::getNoErrors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns number of unread error messages. </p>
<p>Number of unread error messages will be returned.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classintelhex.html#ab881b8cb0fe665395a29e4375db8f7c4" title="Pop next warning message from the list of warnings. ">popNextWarning()</a>, <a class="el" href="classintelhex.html#a05a19e1e9f1eb493a8d0bc29db88683f" title="Returns number of unread warning messages. ">getNoWarnings()</a>, <a class="el" href="classintelhex.html#a6609fd1c57a650c45a1961f6318d643e" title="Pop next error message from the list of errors. ">popNextError()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a05a19e1e9f1eb493a8d0bc29db88683f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long intelhex::getNoWarnings </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns number of unread warning messages. </p>
<p>Number of unread warning messages will be returned.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classintelhex.html#ab881b8cb0fe665395a29e4375db8f7c4" title="Pop next warning message from the list of warnings. ">popNextWarning()</a>, <a class="el" href="classintelhex.html#a77cddd46c3f97692b4d89f138bdabb72" title="Returns number of unread error messages. ">getNoErrors()</a>, <a class="el" href="classintelhex.html#a6609fd1c57a650c45a1961f6318d643e" title="Pop next error message from the list of errors. ">popNextError()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7bc61f72756d37509e768906733ba10b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool intelhex::getStartLinearAddress </td>
          <td>(</td>
          <td class="paramtype">unsigned long *&#160;</td>
          <td class="paramname"><em>eipRegister</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns segment linear address for the EIP register. </p>
<p>If this value exists, they will be returned. If not, the function returns false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eipRegister</td><td>- variable to store EIP register's value</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>- EIP register has defined value </td></tr>
    <tr><td class="paramname">false</td><td>- EIP register do not contain value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classintelhex.html#a94d6d17ba22263a4775d80b2a0e6e95f" title="Returns segment start address for the IP and ES registers. ">getStartSegmentAddress()</a>, <a class="el" href="classintelhex.html#a9688f0002be870b05d64b5f9fcdeb86b" title="Sets the segment start address for the IP and CS registers. ">setStartSegmentAddress()</a>, <a class="el" href="classintelhex.html#a7629ca097b2de02dea37fcaa2dc2709c" title="Sets the segment start address for the EIP register. ">setStartLinearAddress()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a94d6d17ba22263a4775d80b2a0e6e95f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool intelhex::getStartSegmentAddress </td>
          <td>(</td>
          <td class="paramtype">unsigned short *&#160;</td>
          <td class="paramname"><em>ipRegister</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short *&#160;</td>
          <td class="paramname"><em>csRegister</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns segment start address for the IP and ES registers. </p>
<p>If these values exist, they will be returned. If not, the function returns false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ipRegister</td><td>- variable to store IP register's value </td></tr>
    <tr><td class="paramname">csRegister</td><td>- variable to store CS register's value</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>- IP and CS registers have defined values </td></tr>
    <tr><td class="paramname">false</td><td>- IP and CS registers do not contain values</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classintelhex.html#a7bc61f72756d37509e768906733ba10b" title="Returns segment linear address for the EIP register. ">getStartLinearAddress()</a>, <a class="el" href="classintelhex.html#a9688f0002be870b05d64b5f9fcdeb86b" title="Sets the segment start address for the IP and CS registers. ">setStartSegmentAddress()</a>, <a class="el" href="classintelhex.html#a7629ca097b2de02dea37fcaa2dc2709c" title="Sets the segment start address for the EIP register. ">setStartLinearAddress()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af9c6e296e5053fe8378e79445cf480cb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool intelhex::incrementAddress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increments to next piece of data. </p>
<p>Address pointer will take on the address of the next location for which there is data.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classintelhex.html#a51f6d93f1ac2bdf5ddad8be4e1827ce9" title="Decrements to next piece of data. ">decrementAddress()</a></dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>- pointer was incremented; a new data value was found </td></tr>
    <tr><td class="paramname">false</td><td>- end of available data reached; pointer is unchanged </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a71096983db3c24a5ac9b95663937a4ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool intelhex::insertData </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts desired byte at the current address pointer. </p>
<p>Inserts byte of data at the current address pointer</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>- data byte to be inserted</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classintelhex.html#aa8833665b99f0b6ac64fcef7d2116c42" title="Returns the lowest address currently available. ">startAddress()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a00ff4c491fabc5ef207071358e1b9298"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool intelhex::insertData </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a83b54457c121b0f35b21b78fa2ecd712"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool intelhex::jumpTo </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the address pointer to the desired address. </p>
<p>Address pointer will take on the requested address if the address exists in the data stored in memory. If not, the address pointer does not change.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classintelhex.html#a631d8930daeaf04bf0d9ad9c25679a0b" title="Returns the current address being pointed to. ">currentAddress()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>- Desired new address for the address pointer</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>- Address exists; pointer moved successfully </td></tr>
    <tr><td class="paramname">false</td><td>- Address did not exist; pointer not moved </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5055edd337d19037ab254a27016267f8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void intelhex::linearAddressingOn </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Turns on linear addressing mode during encoding. </p>
<p>Uses the Linear Address Record during encoding. </p>

</div>
</div>
<a class="anchor" id="a044d6ab5b10a38ffa40a0b1f55b7e808"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classintelhex.html">intelhex</a>&amp; intelhex::operator++ </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overloaded prefix increment operator. </p>
<p>Overloads the prefix increment operator to move interal iterator to next entry in the ihContent map </p>

</div>
</div>
<a class="anchor" id="ab54337b9681fc0b50e3fdb18ed1714fa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classintelhex.html">intelhex</a> intelhex::operator++ </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overloaded postfix increment operator. </p>
<p>Overloads the postfix increment operator to move interal iterator to next entry in the ihContent map </p>

</div>
</div>
<a class="anchor" id="ab85cbeafe9cc6adcec79f1bc709addca"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classintelhex.html">intelhex</a>&amp; intelhex::operator-- </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overloaded prefix decrement operator. </p>
<p>Overloads the prefix decrement operator to move interal iterator to previous entry in the ihContent map </p>

</div>
</div>
<a class="anchor" id="a90562846d95b5573923f129b82aeceec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classintelhex.html">intelhex</a> intelhex::operator-- </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overloaded postfix decrement operator. </p>
<p>Overloads the postfix decrement operator to move interal iterator to previous entry in the ihContent map </p>

</div>
</div>
<a class="anchor" id="a6408cc3141862454e846378abfad8ecc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classintelhex.html">intelhex</a>&amp; intelhex::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classintelhex.html">intelhex</a> &amp;&#160;</td>
          <td class="paramname"><em>ihSource</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>intelhex Class Assignment Operator. </p>
<p>Implements the assignment operator so that the content of the Intel HEX file in memory can be copied to another 'intelhex' variable. You may want to keep a copy of the original data in memory and only manipulate a copy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ihSource</td><td>- intelhex variable to be assigned to new variable</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">pointer</td><td>to variable to which value is to be assigned </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab4fc2715f4c63d3f31e8d2b0533583e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void intelhex::overwriteData </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a83edcd2329cb52a4bab6bb46463184d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void intelhex::overwriteData </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a6609fd1c57a650c45a1961f6318d643e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool intelhex::popNextError </td>
          <td>(</td>
          <td class="paramtype">string &amp;&#160;</td>
          <td class="paramname"><em>error</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pop next error message from the list of errors. </p>
<p>Next error message is returned from the list of errors. If there are no more errors in the list, no string will be returned unchanged.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">error</td><td>- variable to store error string to be returned</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>- more error messages are available </td></tr>
    <tr><td class="paramname">false</td><td>- no more error messages are available</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classintelhex.html#a05a19e1e9f1eb493a8d0bc29db88683f" title="Returns number of unread warning messages. ">getNoWarnings()</a>, <a class="el" href="classintelhex.html#a77cddd46c3f97692b4d89f138bdabb72" title="Returns number of unread error messages. ">getNoErrors()</a>, <a class="el" href="classintelhex.html#a6609fd1c57a650c45a1961f6318d643e" title="Pop next error message from the list of errors. ">popNextError()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab881b8cb0fe665395a29e4375db8f7c4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool intelhex::popNextWarning </td>
          <td>(</td>
          <td class="paramtype">string &amp;&#160;</td>
          <td class="paramname"><em>warning</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pop next warning message from the list of warnings. </p>
<p>Next warning message is returned from the list of warnings. If there are no more warning in the list, the string will be unchanged.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">warning</td><td>- variable to store warning string to be returned</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>- more warning messages are available </td></tr>
    <tr><td class="paramname">false</td><td>- no more warning messages are available</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classintelhex.html#a05a19e1e9f1eb493a8d0bc29db88683f" title="Returns number of unread warning messages. ">getNoWarnings()</a>, <a class="el" href="classintelhex.html#a77cddd46c3f97692b4d89f138bdabb72" title="Returns number of unread error messages. ">getNoErrors()</a>, <a class="el" href="classintelhex.html#a6609fd1c57a650c45a1961f6318d643e" title="Pop next error message from the list of errors. ">popNextError()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a489fc3b9c34542def2a5167192b291da"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void intelhex::segmentAddressingOn </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Turns on segment addressing mode during encoding. </p>
<p>Uses the Segment Address Record during encoding. </p>

</div>
</div>
<a class="anchor" id="a7629ca097b2de02dea37fcaa2dc2709c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void intelhex::setStartLinearAddress </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>eipRegister</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the segment start address for the EIP register. </p>
<p>Allows user to define or redefine the contents of the EIP register</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eipRegister</td><td>- desired EIP register value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classintelhex.html#a94d6d17ba22263a4775d80b2a0e6e95f" title="Returns segment start address for the IP and ES registers. ">getStartSegmentAddress()</a>, <a class="el" href="classintelhex.html#a9688f0002be870b05d64b5f9fcdeb86b" title="Sets the segment start address for the IP and CS registers. ">setStartSegmentAddress()</a>, <a class="el" href="classintelhex.html#a7bc61f72756d37509e768906733ba10b" title="Returns segment linear address for the EIP register. ">getStartLinearAddress()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a9688f0002be870b05d64b5f9fcdeb86b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void intelhex::setStartSegmentAddress </td>
          <td>(</td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>ipRegister</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>csRegister</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the segment start address for the IP and CS registers. </p>
<p>Allows user to define or redefine the contents of the IP and CS registers</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ipRegister</td><td>- desired IP register value </td></tr>
    <tr><td class="paramname">csRegister</td><td>- desired CS register value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classintelhex.html#a7bc61f72756d37509e768906733ba10b" title="Returns segment linear address for the EIP register. ">getStartLinearAddress()</a>, <a class="el" href="classintelhex.html#a94d6d17ba22263a4775d80b2a0e6e95f" title="Returns segment start address for the IP and ES registers. ">getStartSegmentAddress()</a>, <a class="el" href="classintelhex.html#a7629ca097b2de02dea37fcaa2dc2709c" title="Sets the segment start address for the EIP register. ">setStartLinearAddress()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="afa757932ec420f977d33bb9a2d5a0a69"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long intelhex::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if we have reached end of available data. </p>
<p>The internal pointer is checked to see if we have reached the end of the data held in memory</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classintelhex.html#a044d6ab5b10a38ffa40a0b1f55b7e808" title="Overloaded prefix increment operator. ">operator++()</a>, <a class="el" href="classintelhex.html#ab54337b9681fc0b50e3fdb18ed1714fa" title="Overloaded postfix increment operator. ">operator++(int)</a>, <a class="el" href="classintelhex.html#ab85cbeafe9cc6adcec79f1bc709addca" title="Overloaded prefix decrement operator. ">operator--()</a>, <a class="el" href="classintelhex.html#a90562846d95b5573923f129b82aeceec" title="Overloaded postfix decrement operator. ">operator--(int)</a>, <a class="el" href="classintelhex.html#a2bd5b567207303d4d9f4322e6262d6d6">empty()</a></dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>- reached the end of the Intel HEX data in memory or no data in memory yet. </td></tr>
    <tr><td class="paramname">false</td><td>- end of Intel HEX data in memory not yet reached.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function has no effect if no file has been as yet decoded and no data has been inserted into memory. </dd></dl>

</div>
</div>
<a class="anchor" id="aa8833665b99f0b6ac64fcef7d2116c42"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool intelhex::startAddress </td>
          <td>(</td>
          <td class="paramtype">unsigned long *&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the lowest address currently available. </p>
<p>Returns the first address that appears in the memory if there is data present. If not, no value will be returned.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classintelhex.html#a9b159bea81eb832e37f6cf88a57ca659" title="Returns the highest address currently available. ">endAddress()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>- variable to hold address requested</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>- address existed and returned value is valid </td></tr>
    <tr><td class="paramname">false</td><td>- address did not exist and returned valid is not valid </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5adb32f7af4a3c75fd0745ef2827da9a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char intelhex::stringToHex </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a3185843e9397b26ccd330ead0a9a7bed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string intelhex::ucToHexString </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts an unsigned char to a string in HEX format. </p>
<p>Takes the received paramter and converts it into its equivalent value represented in ASCII and formatted in hexadecimal. Return value is a 2 character long string, prefaced with '0' where necessary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>- a value between 0x00 and 0xFF</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-</td><td>2-character long string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Alpha characters are capitalised.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classintelhex.html#a5adb32f7af4a3c75fd0745ef2827da9a">stringToHex()</a>, <a class="el" href="classintelhex.html#af45f701889bcd7e5d25066a69e0f91bf">ulToHexString()</a>, <a class="el" href="classintelhex.html#a15904358dffd75ddded56657675f3c04" title="Converts an unsigned long to a string in DEC format. ">ulToString()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af45f701889bcd7e5d25066a69e0f91bf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string intelhex::ulToHexString </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a15904358dffd75ddded56657675f3c04"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string intelhex::ulToString </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts an unsigned long to a string in DEC format. </p>
<p>Takes the received paramter and converts it into its equivalent value represented in ASCII and formatted in decimal. Return value will never be longer than a 48 character long string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>- value to be converted</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-</td><td>ASCII string representation of value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classintelhex.html#a5adb32f7af4a3c75fd0745ef2827da9a">stringToHex()</a>, <a class="el" href="classintelhex.html#af45f701889bcd7e5d25066a69e0f91bf">ulToHexString()</a>, <a class="el" href="classintelhex.html#a3185843e9397b26ccd330ead0a9a7bed" title="Converts an unsigned char to a string in HEX format. ">ucToHexString()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3958f077a662291bbde3472ea2bcfb4d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void intelhex::verboseOff </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Turns off textual output to cout during decoding. </p>
<p>No output to cout during decoding of Intel HEX files. </p>

</div>
</div>
<a class="anchor" id="ac6a0119a04a2090af3ffe8c33a37cbc9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void intelhex::verboseOn </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Turns on textual output to cout during decoding. </p>
<p>Per record single line output to cout during decoding of Intel HEX files. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="a320e23dab311a6c652aa7ddb9e2f9cc2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>dataOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classintelhex.html">intelhex</a> &amp;&#160;</td>
          <td class="paramname"><em>ihLocal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Output stream overload operator. </p>
<p>Operator overloaded to encode any data held in memory into the Intel HEX format for storage on disk</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classintelhex.html#a73fb9c5b9d6d069b5eb83340942fd54b" title="Input stream overload operator. ">operator&gt;&gt;()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dataOut</td><td>- Output stream for to store the decoded file information </td></tr>
    <tr><td class="paramname">ihLocal</td><td>- Points to this class so that friend function has access to private class members</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-</td><td>pointer to output stream </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a73fb9c5b9d6d069b5eb83340942fd54b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">istream&amp; operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">istream &amp;&#160;</td>
          <td class="paramname"><em>dataIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classintelhex.html">intelhex</a> &amp;&#160;</td>
          <td class="paramname"><em>ihLocal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Input stream overload operator. </p>
<p>Operator overloaded to decode data streamed in from a file in the Intel HEX format into memory</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classintelhex.html#a320e23dab311a6c652aa7ddb9e2f9cc2" title="Output stream overload operator. ">operator&lt;&lt;()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dataIn</td><td>- Input stream for the encoded file information </td></tr>
    <tr><td class="paramname">ihLocal</td><td>- Points to this class so that friend function has access to private class members</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-</td><td>pointer to input stream </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="aabbf5689bc667734dca7f23a11d3df68"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned short intelhex::csRegister</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="abedd6ca388d3cad1d2525abc5939d27e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long intelhex::eipRegister</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab58b4357deef8e4f0af9817393fc0b6e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool intelhex::exists</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a757b3e3037a34caf004981aed2a297b6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool intelhex::foundEof</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Note that EOF record is found. </p>
<p>Used to note that the EOF record was found in order to ensure that it doesn't appear twice during encoding. </p>

</div>
</div>
<a class="anchor" id="a5add4e9b26e1c467296bec8a94d4ee65"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">map&lt;unsigned long, unsigned char&gt; intelhex::ihContent</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Container for decoded Intel HEX content. </p>
<p>STL map holding the addresses found in the Intel HEX file and the associated data byte stored at that address </p>

</div>
</div>
<a class="anchor" id="a76fb4550b43dfbb08018cabf34298400"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">list&lt;string&gt; intelhex::ihErrors</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="accc24f65b09b8cbe43ec9dba0f315f83"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">map&lt;unsigned long, unsigned char&gt;::iterator intelhex::ihIterator</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterator for the container holding the decoded Intel HEX content. </p>
<p>This iterator is used by the class to point to the location in memory currently being used to read or write data. If no file has been loaded into memory, it points to the start of ihContent. </p>

</div>
</div>
<a class="anchor" id="a4adf41a09983f0f78a11c8fc392c33f8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt;map&lt;unsigned long, unsigned char&gt;::iterator,bool&gt; intelhex::ihReturn</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pair for the container holding the decoded Intel HEX content. </p>
<p>This is used to acquire the result of an attempt to insert new data into ihContent. Since the ihContent is a map STL, it can't allow data to be assigned to the same address more than once. In this way we can ensure that no address in a file is falsely assigned data more than once. </p>

</div>
</div>
<a class="anchor" id="a0ae0e9a75bdfaa50d6d0266bb3d56ed1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">list&lt;string&gt; intelhex::ihWarnings</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="acf63100ba6ba58da893f29596560efbd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned short intelhex::ipRegister</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab3bf00fb9b05d5ed791f38995d510176"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct { ... } 
	 intelhex::msgError</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Structure to hold error messages. </p>
<p>Holds error messages generated during encoding/decoding process and number of messages currently present in system</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ihErrors</td><td>- list of error messages as strings </td></tr>
    <tr><td class="paramname">noOferrors</td><td>- no of error messages still present in the list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1125751a09a972c8ce56d51b6b89d4e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct { ... } 
	 intelhex::msgWarning</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Structure to hold warning messages. </p>
<p>Holds warning messages generated during encoding/decoding process and number of messages currently present in system</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ihWarnings</td><td>- list of warning messages as strings </td></tr>
    <tr><td class="paramname">noOfWarnings</td><td>- no of warning messages still present in the list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a451b78972165b898e91a129670fce919"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long intelhex::noOfErrors</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5ea3789cc9ea71c9b35322aabca05158"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long intelhex::noOfWarnings</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5831ba42a6d900b6b01bade869ac06e7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool intelhex::segmentAddressMode</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Select segment address mode. </p>
<p>If true, use the segment addressing mode when encoding files. otherwise the default linear address mode will be used. Please refer to Intel's Hexadecimal Object File Format Specifiation for further information. </p>

</div>
</div>
<a class="anchor" id="aacb1421e6ecfde72ec6b164d361442d6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long intelhex::segmentBaseAddress</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores segment base address of Intel HEX file. </p>
<p>The segment base address is a 32-bit address to which the current load offset (as found in a Data Record line of the Intel HEX file) is added to calculate the actual address of the data. The Data Records can only point to a 64kByte address, so the segment base address expands the addressing to 4GB. This variable always holds the last address accessed. This variable is only used during file decoding and encoding in the operator&lt;&lt; and operator&gt;&gt; class member friend functions. </p>

</div>
</div>
<a class="anchor" id="a08bee84b2ef4f989a5f15f9eeaf317ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct { ... } 
	 intelhex::startLinearAddress</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stores the content of the EIP Register, if used. </p>
<p>Used to store the content of the EIP Register for HEX files created for x386 Intel processors. This information is retrieved from the the Start Linear Address Record or can be defined by using the <a class="el" href="classintelhex.html#a7629ca097b2de02dea37fcaa2dc2709c" title="Sets the segment start address for the EIP register. ">setStartLinearAddress()</a> function. The found element defines if this register holds valid data or not.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eipRegister</td><td>- content of the EIP register </td></tr>
    <tr><td class="paramname">exists</td><td>- defines if a value for the above register has been written (true) or not (false)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classintelhex.html#a7bc61f72756d37509e768906733ba10b" title="Returns segment linear address for the EIP register. ">getStartLinearAddress()</a>, <a class="el" href="classintelhex.html#a7629ca097b2de02dea37fcaa2dc2709c" title="Sets the segment start address for the EIP register. ">setStartLinearAddress()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab150a4a21506ce25cf3cb1123478ca0c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct { ... } 
	 intelhex::startSegmentAddress</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stores the content of the CS/IP Registers, if used. </p>
<p>Used to store the content of the CS and IS Register for HEX files created for x286 or earlier Intel processors. This information is retrieved from the Start Segment Address Record or can be defined by the user using the <a class="el" href="classintelhex.html#a9688f0002be870b05d64b5f9fcdeb86b" title="Sets the segment start address for the IP and CS registers. ">setStartSegmentAddress()</a> function. The found element defines if these registers hold valid data or not.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">csRegister</td><td>- content of the CS register </td></tr>
    <tr><td class="paramname">ipRegister</td><td>- content of the IP register </td></tr>
    <tr><td class="paramname">exists</td><td>- defines if values for the above registers have been written (true) or not (false)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classintelhex.html#a94d6d17ba22263a4775d80b2a0e6e95f" title="Returns segment start address for the IP and ES registers. ">getStartSegmentAddress()</a>, <a class="el" href="classintelhex.html#a9688f0002be870b05d64b5f9fcdeb86b" title="Sets the segment start address for the IP and CS registers. ">setStartSegmentAddress()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a65f440d3762d1b9437b7473c4df3bb8f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool intelhex::verbose</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Select verbose mode. </p>
<p>Used during development to display messages as the incoming data stream is decoded </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>library/<a class="el" href="intelhexclass_8h_source.html">intelhexclass.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Jan 11 2015 13:27:34 for Wifly_Light by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
